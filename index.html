<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iron Man Holographic Particle Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .hud-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: none;
            background: linear-gradient(180deg, 
                rgba(255, 0, 0, 0.03) 0%,
                rgba(255, 100, 0, 0.01) 50%,
                rgba(255, 0, 0, 0.03) 100%);
        }
        
        .hud-border {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 3;
            pointer-events: none;
            border: 2px solid rgba(255, 40, 40, 0.3);
            box-shadow: 
                inset 0 0 60px rgba(255, 0, 0, 0.2),
                0 0 100px rgba(255, 0, 0, 0.1);
            animation: borderPulse 4s infinite;
        }
        
        @keyframes borderPulse {
            0%, 100% { border-color: rgba(255, 40, 40, 0.3); }
            50% { border-color: rgba(255, 100, 100, 0.5); }
        }
        
        .hud-data {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        .hud-data div {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .hud-label {
            color: #ff9999;
            margin-right: 10px;
            min-width: 120px;
        }
        
        .hud-value {
            color: #ffffff;
            font-weight: bold;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-family: 'Courier New', monospace;
        }
        
        .jarvis-text {
            color: #ff4444;
            font-size: 24px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            animation: textPulse 2s infinite;
        }
        
        @keyframes textPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ff4444, transparent);
            z-index: 5;
            pointer-events: none;
            animation: scan 4s linear infinite;
        }
        
        @keyframes scan {
            0% { top: 0; }
            100% { top: 100%; }
        }
        
        .hand-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 40, 40, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 4;
            font-family: 'Courier New', monospace;
            color: #ff4444;
            font-size: 12px;
            backdrop-filter: blur(5px);
        }
        
        .gesture-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            background-color: #ff4444;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            background: 
                linear-gradient(90deg, rgba(255, 0, 0, 0.03) 1px, transparent 1px) 0 0 / 50px 50px,
                linear-gradient(0deg, rgba(255, 0, 0, 0.03) 1px, transparent 1px) 0 0 / 50px 50px;
            pointer-events: none;
        }
        
        .particle-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 40, 40, 0.5);
            padding: 15px;
            border-radius: 8px;
            z-index: 4;
            font-family: 'Courier New', monospace;
            color: #ff9999;
            font-size: 11px;
            backdrop-filter: blur(5px);
            max-width: 300px;
        }
        
        .particle-info h3 {
            color: #ff4444;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 40, 40, 0.3);
            padding-bottom: 5px;
        }
        
        .hidden {
            display: none;
        }
        
        .fps-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #ff9999;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 4;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255, 40, 40, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>
    <div class="grid-overlay"></div>
    <div class="hud-overlay"></div>
    <div class="hud-border"></div>
    <div class="scan-line"></div>
    
    <div class="hud-data">
        <div><span class="hud-label">SYSTEM STATUS:</span><span class="hud-value">ACTIVE</span></div>
        <div><span class="hud-label">PARTICLE COUNT:</span><span class="hud-value" id="particle-count">0</span></div>
        <div><span class="hud-label">ENERGY LEVEL:</span><span class="hud-value" id="energy-level">100%</span></div>
        <div><span class="hud-label">INTERFACE MODE:</span><span class="hud-value" id="interface-mode">HOLOGRAPHIC</span></div>
        <div><span class="hud-label">GESTURE RECOG:</span><span class="hud-value" id="gesture-status">INITIALIZING</span></div>
    </div>
    
    <div class="hand-indicator">
        <span class="gesture-icon"></span>
        <span id="hand-status">INITIALIZING HAND TRACKING...</span>
    </div>
    
    <div class="particle-info">
        <h3>PARTICLE INTERFACE v2.0</h3>
        <p>Gestures: Open Hand - Swipe Particles ‚úã</p>
        <p>Closed Fist - Form Sphere ‚úä</p>
        <p>Two Fingers - Create Hologram ‚úåÔ∏è</p>
        <p>Pinch - Energy Burst üëå</p>
        <p class="hidden" id="mobile-warning">For best experience, use desktop with webcam</p>
    </div>
    
    <div class="fps-counter">
        FPS: <span id="fps">0</span>
    </div>
    
    <div class="loading" id="loading-screen">
        <div class="jarvis-text">J.A.R.V.I.S. INITIALIZING</div>
        <div style="color: #ff9999; margin-bottom: 20px;">HOLOGRAPHIC PARTICLE INTERFACE</div>
        <div style="width: 300px; height: 2px; background: linear-gradient(90deg, transparent, #ff4444, transparent);"></div>
        <div style="color: #ff6666; margin-top: 30px; font-size: 12px;">Please allow camera access for gesture control</div>
    </div>

    <script>
        // Iron Man Holographic Particle System
        class IronManParticleSystem {
            constructor() {
                // Full screen setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('three-canvas'),
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                
                // Iron Man color scheme
                this.ironManColors = {
                    primary: new THREE.Color(0xff4444),
                    secondary: new THREE.Color(0xff9900),
                    accent: new THREE.Color(0xffff00),
                    energy: new THREE.Color(0x00ffff),
                    hologram: new THREE.Color(0x6666ff)
                };
                
                // Particle system
                this.particles = [];
                this.particleCount = 2000;
                this.particleSize = 0.2;
                this.particleGeometry = new THREE.SphereGeometry(this.particleSize, 4, 4);
                
                // Holographic modes
                this.currentMode = 'holographic';
                this.modes = {
                    'holographic': this.updateHolographicMode.bind(this),
                    'formation': this.updateFormationMode.bind(this),
                    'energy': this.updateEnergyMode.bind(this),
                    'interface': this.updateInterfaceMode.bind(this)
                };
                
                // Hand tracking
                this.hands = null;
                this.handDetected = false;
                this.handPosition = new THREE.Vector3(0, 0, -50);
                this.handVelocity = new THREE.Vector3(0, 0, 0);
                this.lastHandPosition = new THREE.Vector3(0, 0, 0);
                
                // Gesture states
                this.gestures = {
                    isOpenHand: false,
                    isClosedFist: false,
                    isTwoFingers: false,
                    isPinching: false,
                    isRotating: false
                };
                
                // Holographic formations
                this.formations = {
                    'sphere': this.createSphereFormation.bind(this),
                    'helmet': this.createHelmetFormation.bind(this),
                    'arcReactor': this.createArcReactorFormation.bind(this),
                    'hud': this.createHUDFormation.bind(this),
                    'suit': this.createSuitFormation.bind(this)
                };
                this.currentFormation = 'sphere';
                this.forming = false;
                
                // Energy fields
                this.energyFields = [];
                this.energyLevel = 100;
                
                // Animation
                this.clock = new THREE.Clock();
                this.time = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                // UI elements
                this.loadingScreen = document.getElementById('loading-screen');
                this.particleCountElement = document.getElementById('particle-count');
                this.energyLevelElement = document.getElementById('energy-level');
                this.interfaceModeElement = document.getElementById('interface-mode');
                this.gestureStatusElement = document.getElementById('gesture-status');
                this.handStatusElement = document.getElementById('hand-status');
                this.fpsElement = document.getElementById('fps');
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupHandTracking();
                this.createParticleSystem();
                this.createHolographicEffects();
                this.animate();
                
                // Hide loading after initialization
                setTimeout(() => {
                    this.loadingScreen.style.display = 'none';
                }, 2500);
            }
            
            setupScene() {
                // Full screen renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x000000, 1);
                
                // Camera positioned like Iron Man's HUD
                this.camera.position.set(0, 0, 50);
                this.camera.lookAt(0, 0, 0);
                
                // Add dramatic lighting
                const ambientLight = new THREE.AmbientLight(0xff4444, 0.2);
                this.scene.add(ambientLight);
                
                const pointLight1 = new THREE.PointLight(0xff4444, 2, 100);
                pointLight1.position.set(20, 20, 20);
                this.scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0x00ffff, 1, 100);
                pointLight2.position.set(-20, -20, 20);
                this.scene.add(pointLight2);
                
                // Add holographic grid
                const gridHelper = new THREE.GridHelper(200, 100, 0xff4444, 0x330000);
                gridHelper.position.y = -20;
                gridHelper.material.opacity = 0.1;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);
                
                // Create central energy core
                this.createEnergyCore();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            createEnergyCore() {
                // Create central energy source
                const coreGeometry = new THREE.IcosahedronGeometry(5, 3);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4444,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });
                
                this.energyCore = new THREE.Mesh(coreGeometry, coreMaterial);
                this.scene.add(this.energyCore);
                
                // Add energy pulses
                const pulseGeometry = new THREE.SphereGeometry(1, 16, 16);
                const pulseMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4444,
                    transparent: true,
                    opacity: 0.5
                });
                
                this.energyPulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
                this.scene.add(this.energyPulse);
            }
            
            createParticleSystem() {
                // Create particle pool
                for (let i = 0; i < this.particleCount; i++) {
                    this.createParticle(i);
                }
                
                this.particleCountElement.textContent = this.particleCount;
            }
            
            createParticle(index) {
                // Create Iron Man style particle
                const material = new THREE.MeshPhongMaterial({
                    color: this.getParticleColor(index),
                    emissive: this.getParticleColor(index).clone().multiplyScalar(0.5),
                    shininess: 100,
                    transparent: true,
                    opacity: 0.8
                });
                
                const particle = new THREE.Mesh(this.particleGeometry, material);
                
                // Initial random position in sphere
                const radius = 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                particle.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                // Store particle data
                const particleData = {
                    mesh: particle,
                    originalPosition: particle.position.clone(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    ),
                    targetPosition: particle.position.clone(),
                    color: material.color,
                    energy: 1,
                    phase: Math.random() * Math.PI * 2,
                    size: this.particleSize
                };
                
                this.particles.push(particleData);
                this.scene.add(particle);
            }
            
            getParticleColor(index) {
                // Create Iron Man color scheme
                const colors = [
                    this.ironManColors.primary,
                    this.ironManColors.secondary,
                    this.ironManColors.accent,
                    this.ironManColors.energy
                ];
                
                const colorIndex = Math.floor(index / (this.particleCount / colors.length));
                return colors[colorIndex % colors.length].clone();
            }
            
            createHolographicEffects() {
                // Create holographic lines connecting particles
                this.lineGeometry = new THREE.BufferGeometry();
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xff4444,
                    transparent: true,
                    opacity: 0.1,
                    blending: THREE.AdditiveBlending
                });
                
                this.holographicLines = new THREE.LineSegments(this.lineGeometry, lineMaterial);
                this.scene.add(this.holographicLines);
            }
            
            setupHandTracking() {
                // Check if mobile device
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    this.handStatusElement.textContent = "DESKTOP RECOMMENDED FOR GESTURES";
                    return;
                }
                
                // Initialize MediaPipe Hands
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                this.hands.onResults(this.onHandResults.bind(this));
                
                // Create video element for hand tracking
                const video = document.createElement('video');
                video.style.display = 'none';
                document.body.appendChild(video);
                
                // Start camera
                const camera = new Camera(video, {
                    onFrame: async () => {
                        if (this.hands) {
                            await this.hands.send({ image: video });
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
            }
            
            onHandResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    this.handDetected = true;
                    
                    // Calculate hand center (palm)
                    const palmBase = landmarks[0];
                    const middleBase = landmarks[9];
                    
                    // Map to 3D space
                    const screenX = (palmBase.x + middleBase.x) / 2;
                    const screenY = (palmBase.y + middleBase.y) / 2;
                    
                    // Update hand position (in front of camera)
                    const targetX = (screenX - 0.5) * 100;
                    const targetY = -(screenY - 0.5) * 80;
                    const targetZ = -30;
                    
                    // Smooth movement
                    this.handPosition.x += (targetX - this.handPosition.x) * 0.3;
                    this.handPosition.y += (targetY - this.handPosition.y) * 0.3;
                    this.handPosition.z = targetZ;
                    
                    // Calculate velocity
                    const deltaTime = this.clock.getDelta();
                    if (deltaTime > 0) {
                        this.handVelocity.x = (this.handPosition.x - this.lastHandPosition.x) / deltaTime;
                        this.handVelocity.y = (this.handPosition.y - this.lastHandPosition.y) / deltaTime;
                        this.handVelocity.z = (this.handPosition.z - this.lastHandPosition.z) / deltaTime;
                    }
                    this.lastHandPosition.copy(this.handPosition);
                    
                    // Detect gestures
                    this.detectGestures(landmarks);
                    
                    this.handStatusElement.textContent = "HAND TRACKING ACTIVE";
                    this.gestureStatusElement.textContent = "ACTIVE";
                    
                } else {
                    this.handDetected = false;
                    this.handStatusElement.textContent = "AWAITING HAND INPUT";
                    this.gestureStatusElement.textContent = "STANDBY";
                }
            }
            
            detectGestures(landmarks) {
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const wrist = landmarks[0];
                
                // Reset gestures
                Object.keys(this.gestures).forEach(key => this.gestures[key] = false);
                
                // Calculate distances
                const distances = {
                    thumb: this.calculateDistance(thumbTip, wrist),
                    index: this.calculateDistance(indexTip, wrist),
                    middle: this.calculateDistance(middleTip, wrist),
                    ring: this.calculateDistance(ringTip, wrist),
                    pinky: this.calculateDistance(pinkyTip, wrist)
                };
                
                const avgDistance = (distances.thumb + distances.index + distances.middle + distances.ring + distances.pinky) / 5;
                
                // Detect pinch (thumb and index close)
                const pinchDistance = this.calculateDistance(thumbTip, indexTip);
                if (pinchDistance < 0.05) {
                    this.gestures.isPinching = true;
                    this.currentMode = 'energy';
                    this.interfaceModeElement.textContent = "ENERGY BURST";
                }
                // Detect closed fist
                else if (distances.index < avgDistance * 0.6 && 
                         distances.middle < avgDistance * 0.6) {
                    this.gestures.isClosedFist = true;
                    this.currentMode = 'formation';
                    this.interfaceModeElement.textContent = "FORMATION MODE";
                    this.currentFormation = 'sphere';
                }
                // Detect two fingers
                else if (distances.index > avgDistance * 1.3 && 
                         distances.middle > avgDistance * 1.3 &&
                         distances.ring < avgDistance * 0.8) {
                    this.gestures.isTwoFingers = true;
                    this.currentMode = 'interface';
                    this.interfaceModeElement.textContent = "HOLOGRAM UI";
                    this.currentFormation = 'hud';
                }
                // Default open hand
                else {
                    this.gestures.isOpenHand = true;
                    this.currentMode = 'holographic';
                    this.interfaceModeElement.textContent = "HOLOGRAPHIC";
                }
            }
            
            calculateDistance(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const dz = point1.z - point2.z;
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            }
            
            updateHolographicMode() {
                // Iron Man's fluid, intelligent particle movement
                this.time += this.clock.getDelta();
                
                this.particles.forEach((particle, i) => {
                    // Base hovering motion
                    const hover = Math.sin(this.time + particle.phase) * 0.5;
                    
                    // Gentle drift
                    particle.velocity.x += (Math.random() - 0.5) * 0.01;
                    particle.velocity.y += (Math.random() - 0.5) * 0.01;
                    particle.velocity.z += (Math.random() - 0.5) * 0.01;
                    
                    // Limit velocity
                    particle.velocity.clampLength(0, 2);
                    
                    // Apply velocity
                    particle.mesh.position.add(particle.velocity);
                    
                    // Return to original area gradually
                    const returnForce = particle.originalPosition.clone()
                        .sub(particle.mesh.position)
                        .multiplyScalar(0.002);
                    
                    particle.velocity.add(returnForce);
                    
                    // Damping
                    particle.velocity.multiplyScalar(0.99);
                    
                    // Hand interaction for open hand
                    if (this.handDetected && this.gestures.isOpenHand) {
                        const handDistance = particle.mesh.position.distanceTo(this.handPosition);
                        
                        if (handDistance < 20) {
                            // Repel particles from hand
                            const repelForce = particle.mesh.position.clone()
                                .sub(this.handPosition)
                                .normalize()
                                .multiplyScalar(0.5 / (handDistance + 1));
                            
                            particle.velocity.add(repelForce);
                            
                            // Add hand velocity influence
                            particle.velocity.add(this.handVelocity.clone().multiplyScalar(0.1));
                        }
                    }
                    
                    // Energy pulsing
                    const pulse = Math.sin(this.time * 2 + i * 0.01) * 0.1 + 0.9;
                    particle.mesh.material.emissiveIntensity = pulse;
                    particle.mesh.scale.setScalar(pulse);
                });
            }
            
            updateFormationMode() {
                if (this.gestures.isClosedFist) {
                    // Form particles into sphere around hand
                    const formationRadius = 15;
                    const formationSpeed = 0.05;
                    
                    this.particles.forEach((particle, i) => {
                        const angle = (i / this.particles.length) * Math.PI * 2;
                        const phi = Math.acos(1 - 2 * i / this.particles.length);
                        
                        const targetPos = new THREE.Vector3(
                            this.handPosition.x + formationRadius * Math.sin(phi) * Math.cos(angle),
                            this.handPosition.y + formationRadius * Math.sin(phi) * Math.sin(angle),
                            this.handPosition.z + formationRadius * Math.cos(phi)
                        );
                        
                        // Move toward target
                        particle.velocity.add(
                            targetPos.sub(particle.mesh.position).multiplyScalar(formationSpeed)
                        );
                        
                        // Energy effect
                        particle.mesh.material.emissiveIntensity = 1.5;
                        particle.mesh.scale.setScalar(1.2);
                    });
                }
            }
            
            updateEnergyMode() {
                if (this.gestures.isPinching) {
                    // Create energy burst from pinch
                    this.energyLevel = Math.min(100, this.energyLevel + 0.5);
                    
                    this.particles.forEach(particle => {
                        const distance = particle.mesh.position.distanceTo(this.handPosition);
                        
                        if (distance < 30) {
                            // Attract to pinch point
                            const attractForce = this.handPosition.clone()
                                .sub(particle.mesh.position)
                                .normalize()
                                .multiplyScalar(1.0 / (distance + 1));
                            
                            particle.velocity.add(attractForce);
                            
                            // Energy charging effect
                            particle.mesh.material.color.lerp(this.ironManColors.energy, 0.1);
                            particle.mesh.material.emissiveIntensity = 2;
                            particle.mesh.scale.setScalar(1.5);
                        }
                    });
                } else {
                    // Gradually return to normal
                    this.energyLevel = Math.max(0, this.energyLevel - 0.1);
                    
                    this.particles.forEach(particle => {
                        particle.mesh.material.color.lerp(particle.color, 0.05);
                        particle.mesh.material.emissiveIntensity = 1;
                        particle.mesh.scale.setScalar(1);
                    });
                }
                
                this.energyLevelElement.textContent = `${Math.round(this.energyLevel)}%`;
            }
            
            updateInterfaceMode() {
                if (this.gestures.isTwoFingers) {
                    // Create HUD-like interface
                    const hudSize = 20;
                    
                    this.particles.forEach((particle, i) => {
                        const row = Math.floor(i / 50);
                        const col = i % 50;
                        
                        const targetPos = new THREE.Vector3(
                            this.handPosition.x + (col - 25) * 1.5,
                            this.handPosition.y + (row - 10) * 1.5,
                            this.handPosition.z
                        );
                        
                        // Snap to grid
                        particle.velocity.add(
                            targetPos.sub(particle.mesh.position).multiplyScalar(0.1)
                        );
                        
                        // HUD glow effect
                        particle.mesh.material.emissiveIntensity = 1.2;
                        particle.mesh.material.color.lerp(this.ironManColors.hologram, 0.2);
                    });
                }
            }
            
            updateHolographicLines() {
                // Update connections between nearby particles
                const positions = [];
                const maxConnections = 1000;
                let connectionCount = 0;
                
                for (let i = 0; i < this.particles.length && connectionCount < maxConnections; i++) {
                    for (let j = i + 1; j < this.particles.length && connectionCount < maxConnections; j++) {
                        const distance = this.particles[i].mesh.position.distanceTo(this.particles[j].mesh.position);
                        
                        if (distance < 10) {
                            // Create line between particles
                            positions.push(
                                this.particles[i].mesh.position.x,
                                this.particles[i].mesh.position.y,
                                this.particles[i].mesh.position.z
                            );
                            positions.push(
                                this.particles[j].mesh.position.x,
                                this.particles[j].mesh.position.y,
                                this.particles[j].mesh.position.z
                            );
                            connectionCount++;
                        }
                    }
                }
                
                // Update line geometry
                this.lineGeometry.setAttribute('position', 
                    new THREE.Float32BufferAttribute(positions, 3));
                this.lineGeometry.attributes.position.needsUpdate = true;
            }
            
            updateEnergyCore() {
                // Animate central energy core
                if (this.energyCore) {
                    this.energyCore.rotation.x += 0.005;
                    this.energyCore.rotation.y += 0.01;
                    
                    // Pulse animation
                    const pulse = Math.sin(this.time * 2) * 0.5 + 1.5;
                    this.energyCore.scale.setScalar(pulse);
                }
                
                if (this.energyPulse) {
                    this.energyPulse.rotation.x += 0.01;
                    this.energyPulse.rotation.y += 0.02;
                    
                    // Expanding/contracting pulse
                    const pulseSize = Math.sin(this.time * 3) * 2 + 3;
                    this.energyPulse.scale.setScalar(pulseSize);
                    
                    // Fade in/out
                    this.energyPulse.material.opacity = Math.sin(this.time) * 0.3 + 0.3;
                }
            }
            
            updateFPS() {
                this.frameCount++;
                const currentTime = performance.now() / 1000;
                
                if (currentTime - this.lastFpsUpdate >= 1) {
                    this.fpsElement.textContent = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update time
                this.time += this.clock.getDelta();
                
                // Update current mode
                if (this.modes[this.currentMode]) {
                    this.modes[this.currentMode]();
                }
                
                // Update holographic connections
                this.updateHolographicLines();
                
                // Update energy core
                this.updateEnergyCore();
                
                // Update FPS
                this.updateFPS();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new IronManParticleSystem();
        });
    </script>
</body>
    </html>
