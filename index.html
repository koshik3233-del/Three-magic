<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle System with Hand Gestures</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            padding: 15px 20px;
            background: rgba(10, 10, 26, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-right: 20px;
        }
        
        .container {
            display: flex;
            flex: 1;
            position: relative;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .sidebar {
            width: 280px;
            background: rgba(20, 20, 40, 0.85);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #4a9eff;
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
            padding-bottom: 5px;
        }
        
        .template-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .template-btn {
            padding: 10px;
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(100, 100, 200, 0.3);
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .template-btn:hover {
            background: rgba(40, 40, 80, 0.9);
            color: #ddd;
        }
        
        .template-btn.active {
            background: rgba(74, 158, 255, 0.3);
            border-color: #4a9eff;
            color: #fff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .slider-value {
            float: right;
            color: #4a9eff;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .gesture-info {
            background: rgba(30, 30, 60, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #ff00cc;
        }
        
        .gesture-info h3 {
            color: #ff00cc;
            margin-bottom: 10px;
        }
        
        .gesture-info p {
            color: #aaa;
            line-height: 1.5;
        }
        
        .status-bar {
            padding: 10px 20px;
            background: rgba(10, 10, 26, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid rgba(74, 158, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            z-index: 5;
            background: #000;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .gesture-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .gesture-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
            border-radius: 50%;
        }
        
        .gesture-open { background-color: #4CAF50; }
        .gesture-closed { background-color: #FF5722; }
        .gesture-pointing { background-color: #2196F3; }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 26, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .spinner {
            border: 5px solid rgba(74, 158, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid #4a9eff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 300px;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .camera-feed {
                width: 150px;
                height: 113px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Interactive 3D Particle System with Hand Gestures</h1>
        <div class="gesture-indicator">
            <span class="gesture-icon gesture-open" id="gesture-icon"></span>
            <span id="gesture-status">Loading hand tracking...</span>
        </div>
    </header>
    
    <div class="container">
        <div id="canvas-container">
            <canvas id="three-canvas"></canvas>
            
            <div class="camera-feed">
                <video id="video" autoplay muted></video>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="control-group">
                <h2>Particle Templates</h2>
                <div class="template-buttons">
                    <button class="template-btn active" data-template="fireworks">Fireworks</button>
                    <button class="template-btn" data-template="hearts">Hearts</button>
                    <button class="template-btn" data-template="flowers">Flowers</button>
                    <button class="template-btn" data-template="saturn">Saturn Rings</button>
                    <button class="template-btn" data-template="spiral">Spiral Galaxy</button>
                    <button class="template-btn" data-template="swarm">Particle Swarm</button>
                </div>
            </div>
            
            <div class="control-group">
                <h2>Particle Controls</h2>
                <div class="slider-container">
                    <label>Particle Size <span class="slider-value" id="size-value">5</span></label>
                    <input type="range" id="size-slider" min="1" max="20" value="5" step="0.5">
                </div>
                
                <div class="slider-container">
                    <label>Particle Count <span class="slider-value" id="count-value">1500</span></label>
                    <input type="range" id="count-slider" min="100" max="5000" value="1500" step="100">
                </div>
                
                <div class="slider-container">
                    <label>Animation Speed <span class="slider-value" id="speed-value">1.0</span></label>
                    <input type="range" id="speed-slider" min="0.1" max="3" value="1.0" step="0.1">
                </div>
                
                <div class="slider-container">
                    <label>Color Intensity <span class="slider-value" id="color-value">0.8</span></label>
                    <input type="range" id="color-slider" min="0.1" max="2" value="0.8" step="0.1">
                </div>
            </div>
            
            <div class="gesture-info">
                <h3>Hand Gesture Controls</h3>
                <p><strong>Open Hand:</strong> Particles expand and follow your hand movement</p>
                <p><strong>Closed Fist:</strong> Particles contract and change color</p>
                <p><strong>Pointing:</strong> Particles move in the direction you're pointing</p>
                <p><strong>Two Fingers:</strong> Switch between particle templates</p>
                <p>Move your hand in front of your camera to interact with the particles.</p>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <div>Particles: <span id="particle-count">1500</span> | FPS: <span id="fps-counter">0</span></div>
        <div>Template: <span id="template-name">Fireworks</span></div>
    </div>
    
    <div class="loading" id="loading-screen">
        <div class="spinner"></div>
        <p>Initializing hand tracking and 3D particle system...</p>
        <p>Please allow camera access when prompted.</p>
    </div>

    <script>
        // Main Three.js application
        class ParticleSystem {
            constructor() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('three-canvas'),
                    antialias: true,
                    alpha: true 
                });
                
                // Particle properties
                this.particles = null;
                this.particleCount = 1500;
                this.particleSize = 5;
                this.animationSpeed = 1.0;
                this.colorIntensity = 0.8;
                this.currentTemplate = 'fireworks';
                this.templates = {
                    'fireworks': this.createFireworksTemplate,
                    'hearts': this.createHeartsTemplate,
                    'flowers': this.createFlowersTemplate,
                    'saturn': this.createSaturnTemplate,
                    'spiral': this.createSpiralTemplate,
                    'swarm': this.createSwarmTemplate
                };
                
                // Hand tracking
                this.hands = null;
                this.videoElement = document.getElementById('video');
                this.gestureStatus = document.getElementById('gesture-status');
                this.gestureIcon = document.getElementById('gesture-icon');
                this.lastGesture = 'none';
                
                // Gesture control
                this.handPosition = { x: 0, y: 0, z: 0 };
                this.isHandClosed = false;
                this.isPointing = false;
                this.twoFingersDetected = false;
                
                // Animation
                this.clock = new THREE.Clock();
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                // UI elements
                this.sizeSlider = document.getElementById('size-slider');
                this.countSlider = document.getElementById('count-slider');
                this.speedSlider = document.getElementById('speed-slider');
                this.colorSlider = document.getElementById('color-slider');
                this.sizeValue = document.getElementById('size-value');
                this.countValue = document.getElementById('count-value');
                this.speedValue = document.getElementById('speed-value');
                this.colorValue = document.getElementById('color-value');
                this.particleCountDisplay = document.getElementById('particle-count');
                this.fpsCounter = document.getElementById('fps-counter');
                this.templateName = document.getElementById('template-name');
                this.templateButtons = document.querySelectorAll('.template-btn');
                this.loadingScreen = document.getElementById('loading-screen');
                
                this.init();
            }
            
            init() {
                // Setup Three.js
                this.setupScene();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Setup hand tracking
                this.setupHandTracking();
                
                // Create initial particle system
                this.createParticleSystem();
                
                // Start animation loop
                this.animate();
                
                // Hide loading screen after a delay
                setTimeout(() => {
                    this.loadingScreen.style.display = 'none';
                }, 2000);
            }
            
            setupScene() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x0a0a1a, 1);
                
                // Setup camera
                this.camera.position.z = 30;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                this.scene.add(directionalLight);
                
                // Add some subtle background particles
                this.createBackgroundStars();
            }
            
            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Slider controls
                this.sizeSlider.addEventListener('input', (e) => {
                    this.particleSize = parseFloat(e.target.value);
                    this.sizeValue.textContent = this.particleSize;
                    this.updateParticleSize();
                });
                
                this.countSlider.addEventListener('input', (e) => {
                    this.particleCount = parseInt(e.target.value);
                    this.countValue.textContent = this.particleCount;
                    this.particleCountDisplay.textContent = this.particleCount;
                    this.createParticleSystem();
                });
                
                this.speedSlider.addEventListener('input', (e) => {
                    this.animationSpeed = parseFloat(e.target.value);
                    this.speedValue.textContent = this.animationSpeed;
                });
                
                this.colorSlider.addEventListener('input', (e) => {
                    this.colorIntensity = parseFloat(e.target.value);
                    this.colorValue.textContent = this.colorIntensity;
                });
                
                // Template buttons
                this.templateButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        const template = e.target.dataset.template;
                        this.setTemplate(template);
                        
                        // Update active button
                        this.templateButtons.forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });
            }
            
            setupHandTracking() {
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.hands.onResults(this.onHandResults.bind(this));
                
                // Start camera
                const camera = new Camera(this.videoElement, {
                    onFrame: async () => {
                        await this.hands.send({ image: this.videoElement });
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
            }
            
            onHandResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Calculate hand center position
                    let sumX = 0, sumY = 0, sumZ = 0;
                    landmarks.forEach(landmark => {
                        sumX += landmark.x;
                        sumY += landmark.y;
                        sumZ += landmark.z;
                    });
                    
                    this.handPosition.x = (sumX / landmarks.length - 0.5) * 2;
                    this.handPosition.y = -(sumY / landmarks.length - 0.5) * 2;
                    this.handPosition.z = sumZ / landmarks.length;
                    
                    // Detect gestures
                    this.detectGestures(landmarks);
                } else {
                    this.gestureStatus.textContent = "No hand detected";
                    this.gestureIcon.className = "gesture-icon";
                    this.lastGesture = 'none';
                }
            }
            
            detectGestures(landmarks) {
                // Simplified gesture detection based on finger positions
                const wrist = landmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                
                // Calculate distances from wrist to finger tips
                const thumbDistance = this.distance(thumbTip, wrist);
                const indexDistance = this.distance(indexTip, wrist);
                const middleDistance = this.distance(middleTip, wrist);
                const ringDistance = this.distance(ringTip, wrist);
                const pinkyDistance = this.distance(pinkyTip, wrist);
                
                // Calculate average finger distance
                const avgDistance = (thumbDistance + indexDistance + middleDistance + ringDistance + pinkyDistance) / 5;
                
                // Detect closed fist (all fingers close to wrist)
                if (thumbDistance < avgDistance * 0.7 && 
                    indexDistance < avgDistance * 0.7 && 
                    middleDistance < avgDistance * 0.7) {
                    this.isHandClosed = true;
                    this.isPointing = false;
                    this.twoFingersDetected = false;
                    this.updateGestureUI('closed', 'Closed Fist');
                } 
                // Detect pointing (only index finger extended)
                else if (indexDistance > avgDistance * 1.3 && 
                         thumbDistance < avgDistance * 1.1 &&
                         middleDistance < avgDistance * 1.1) {
                    this.isHandClosed = false;
                    this.isPointing = true;
                    this.twoFingersDetected = false;
                    this.updateGestureUI('pointing', 'Pointing');
                }
                // Detect two fingers (peace sign)
                else if (indexDistance > avgDistance * 1.3 && 
                         middleDistance > avgDistance * 1.3 &&
                         thumbDistance < avgDistance * 1.1 &&
                         ringDistance < avgDistance * 1.1) {
                    this.isHandClosed = false;
                    this.isPointing = false;
                    
                    // Only trigger template change once per gesture
                    if (!this.twoFingersDetected) {
                        this.twoFingersDetected = true;
                        this.cycleTemplates();
                    }
                    this.updateGestureUI('open', 'Two Fingers - Changing Template');
                }
                // Open hand
                else {
                    this.isHandClosed = false;
                    this.isPointing = false;
                    this.twoFingersDetected = false;
                    this.updateGestureUI('open', 'Open Hand');
                }
            }
            
            distance(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const dz = point1.z - point2.z;
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            }
            
            updateGestureUI(gestureType, gestureText) {
                if (this.lastGesture !== gestureType) {
                    this.gestureStatus.textContent = gestureText;
                    this.gestureIcon.className = "gesture-icon";
                    
                    if (gestureType === 'open') {
                        this.gestureIcon.classList.add('gesture-open');
                    } else if (gestureType === 'closed') {
                        this.gestureIcon.classList.add('gesture-closed');
                    } else if (gestureType === 'pointing') {
                        this.gestureIcon.classList.add('gesture-pointing');
                    }
                    
                    this.lastGesture = gestureType;
                }
            }
            
            cycleTemplates() {
                const templates = ['fireworks', 'hearts', 'flowers', 'saturn', 'spiral', 'swarm'];
                const currentIndex = templates.indexOf(this.currentTemplate);
                const nextIndex = (currentIndex + 1) % templates.length;
                const nextTemplate = templates[nextIndex];
                
                this.setTemplate(nextTemplate);
                
                // Update active button
                this.templateButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.template === nextTemplate) {
                        btn.classList.add('active');
                    }
                });
            }
            
            setTemplate(templateName) {
                this.currentTemplate = templateName;
                this.templateName.textContent = templateName.charAt(0).toUpperCase() + templateName.slice(1);
                this.createParticleSystem();
            }
            
            createParticleSystem() {
                // Remove existing particles
                if (this.particles) {
                    this.scene.remove(this.particles);
                    this.particles.geometry.dispose();
                    this.particles.material.dispose();
                }
                
                // Create new particle system based on template
                const templateFunction = this.templates[this.currentTemplate];
                const particleData = templateFunction.call(this);
                
                // Create geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(particleData.positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleData.colors, 3));
                
                // Create material
                const material = new THREE.PointsMaterial({
                    size: this.particleSize,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Create points
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
                
                // Store initial positions for animation
                this.initialPositions = particleData.positions.slice();
                this.animationData = particleData.animationData;
            }
            
            createFireworksTemplate() {
                const positions = [];
                const colors = [];
                const animationData = [];
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Random spherical distribution
                    const radius = Math.random() * 15 + 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    positions.push(x, y, z);
                    
                    // Color based on position
                    const r = 0.5 + 0.5 * Math.sin(x * 0.5);
                    const g = 0.5 + 0.5 * Math.sin(y * 0.3);
                    const b = 0.5 + 0.5 * Math.sin(z * 0.7);
                    
                    colors.push(r * this.colorIntensity, g * this.colorIntensity, b * this.colorIntensity);
                    
                    // Animation data
                    animationData.push({
                        speed: 0.5 + Math.random() * 1.5,
                        angle: Math.random() * Math.PI * 2,
                        radius: radius,
                        phase: Math.random() * Math.PI * 2
                    });
                }
                
                return { positions, colors, animationData };
            }
            
            createHeartsTemplate() {
                const positions = [];
                const colors = [];
                const animationData = [];
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Heart shape equation
                    const t = Math.random() * Math.PI * 2;
                    const scale = 8 + Math.random() * 5;
                    
                    const x = scale * 16 * Math.pow(Math.sin(t), 3);
                    const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    const z = (Math.random() - 0.5) * 10;
                    
                    positions.push(x * 0.05, y * 0.05 - 5, z);
                    
                    // Red/pink colors for hearts
                    const r = 0.8 + Math.random() * 0.2;
                    const g = 0.1 + Math.random() * 0.2;
                    const b = 0.3 + Math.random() * 0.2;
                    
                    colors.push(r * this.colorIntensity, g * this.colorIntensity, b * this.colorIntensity);
                    
                    // Animation data
                    animationData.push({
                        speed: 0.3 + Math.random() * 0.7,
                        angle: t,
                        radius: Math.sqrt(x*x + y*y) * 0.05,
                        phase: Math.random() * Math.PI * 2,
                        heartbeat: Math.random() * 0.1
                    });
                }
                
                return { positions, colors, animationData };
            }
            
            createFlowersTemplate() {
                const positions = [];
                const colors = [];
                const animationData = [];
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Flower pattern
                    const petalCount = 5 + Math.floor(Math.random() * 3);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 3 + Math.random() * 10;
                    
                    const petalAngle = angle * petalCount;
                    const petalRadius = radius * (0.8 + 0.2 * Math.sin(petalAngle));
                    
                    const x = petalRadius * Math.cos(angle);
                    const y = petalRadius * Math.sin(angle);
                    const z = (Math.random() - 0.5) * 8;
                    
                    positions.push(x, y, z);
                    
                    // Flower-like colors
                    const r = 0.7 + Math.random() * 0.3;
                    const g = 0.3 + Math.random() * 0.3;
                    const b = 0.5 + Math.random() * 0.3;
                    
                    colors.push(r * this.colorIntensity, g * this.colorIntensity, b * this.colorIntensity);
                    
                    // Animation data
                    animationData.push({
                        speed: 0.2 + Math.random() * 0.5,
                        angle: angle,
                        radius: petalRadius,
                        phase: Math.random() * Math.PI * 2,
                        petalCount: petalCount
                    });
                }
                
                return { positions, colors, animationData };
            }
            
            createSaturnTemplate() {
                const positions = [];
                const colors = [];
                const animationData = [];
                
                // Create ring particles
                for (let i = 0; i < this.particleCount; i++) {
                    const ringRadius = 10 + Math.random() * 8;
                    const ringAngle = Math.random() * Math.PI * 2;
                    const ringWidth = Math.random() * 3;
                    
                    const x = ringRadius * Math.cos(ringAngle);
                    const y = (Math.random() - 0.5) * ringWidth;
                    const z = ringRadius * Math.sin(ringAngle);
                    
                    positions.push(x, y, z);
                    
                    // Saturn-like colors (golden/brown)
                    const r = 0.8 + Math.random() * 0.2;
                    const g = 0.6 + Math.random() * 0.2;
                    const b = 0.2 + Math.random() * 0.2;
                    
                    colors.push(r * this.colorIntensity, g * this.colorIntensity, b * this.colorIntensity);
                    
                    // Animation data
                    animationData.push({
                        speed: 0.1 + Math.random() * 0.3,
                        angle: ringAngle,
                        radius: ringRadius,
                        phase: Math.random() * Math.PI * 2,
                        ringWidth: ringWidth
                    });
                }
                
                return { positions, colors, animationData };
            }
            
            createSpiralTemplate() {
                const positions = [];
                const colors = [];
                const animationData = [];
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Spiral galaxy pattern
                    const spiralArms = 3;
                    const armIndex = i % spiralArms;
                    const armAngle = (armIndex / spiralArms) * Math.PI * 2;
                    
                    const t = Math.random();
                    const radius = 5 + t * 15;
                    const angle = armAngle + t * Math.PI * 4 + (Math.random() - 0.5) * 0.5;
                    
                    const x = radius * Math.cos(angle);
                    const y = (Math.random() - 0.5) * 2;
                    const z = radius * Math.sin(angle);
                    
                    positions.push(x, y, z);
                    
                    // Galaxy colors (blue/purple)
                    const r = 0.3 + t * 0.3;
                    const g = 0.2 + t * 0.2;
                    const b = 0.7 + t * 0.3;
                    
                    colors.push(r * this.colorIntensity, g * this.colorIntensity, b * this.colorIntensity);
                    
                    // Animation data
                    animationData.push({
                        speed: 0.05 + t * 0.1,
                        angle: angle,
                        radius: radius,
                        phase: Math.random() * Math.PI * 2,
                        spiralArm: armIndex
                    });
                }
                
                return { positions, colors, animationData };
            }
            
            createSwarmTemplate() {
                const positions = [];
                const colors = [];
                const animationData = [];
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Swarm cluster
                    const clusterRadius = Math.random() * 10;
                    const clusterAngle = Math.random() * Math.PI * 2;
                    const clusterHeight = (Math.random() - 0.5) * 8;
                    
                    const x = clusterRadius * Math.cos(clusterAngle) + (Math.random() - 0.5) * 3;
                    const y = clusterHeight + (Math.random() - 0.5) * 3;
                    const z = clusterRadius * Math.sin(clusterAngle) + (Math.random() - 0.5) * 3;
                    
                    positions.push(x, y, z);
                    
                    // Swarm colors (green/yellow)
                    const r = 0.3 + Math.random() * 0.3;
                    const g = 0.7 + Math.random() * 0.3;
                    const b = 0.1 + Math.random() * 0.3;
                    
                    colors.push(r * this.colorIntensity, g * this.colorIntensity, b * this.colorIntensity);
                    
                    // Animation data
                    animationData.push({
                        speed: 0.8 + Math.random() * 1.2,
                        angle: clusterAngle,
                        radius: clusterRadius,
                        phase: Math.random() * Math.PI * 2,
                        randomness: Math.random()
                    });
                }
                
                return { positions, colors, animationData };
            }
            
            createBackgroundStars() {
                const starCount = 500;
                const starPositions = [];
                const starColors = [];
                
                for (let i = 0; i < starCount; i++) {
                    // Distant stars
                    const radius = 50 + Math.random() * 200;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    starPositions.push(x, y, z);
                    
                    // Subtle star colors
                    const brightness = 0.2 + Math.random() * 0.3;
                    starColors.push(brightness, brightness, brightness);
                }
                
                const starGeometry = new THREE.BufferGeometry();
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.5
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(stars);
            }
            
            updateParticleSize() {
                if (this.particles) {
                    this.particles.material.size = this.particleSize;
                }
            }
            
            updateParticles() {
                if (!this.particles) return;
                
                const positions = this.particles.geometry.attributes.position.array;
                const colors = this.particles.geometry.attributes.color.array;
                const time = this.clock.getElapsedTime() * this.animationSpeed;
                
                // Apply hand gesture effects
                const handX = this.handPosition.x * 20;
                const handY = this.handPosition.y * 20;
                const handZ = this.handPosition.z * 10;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const idx = i / 3;
                    const animData = this.animationData[idx];
                    
                    // Base position from initial positions
                    let x = this.initialPositions[i];
                    let y = this.initialPositions[i + 1];
                    let z = this.initialPositions[i + 2];
                    
                    // Template-specific animations
                    if (this.currentTemplate === 'fireworks') {
                        const pulse = Math.sin(time * animData.speed + animData.phase) * 2;
                        x += pulse * Math.cos(animData.angle);
                        y += pulse * Math.sin(animData.angle);
                        z += pulse * Math.cos(animData.phase);
                    } 
                    else if (this.currentTemplate === 'hearts') {
                        const heartbeat = Math.sin(time * 2 + animData.phase) * animData.heartbeat;
                        x *= (1 + heartbeat);
                        y *= (1 + heartbeat);
                    }
                    else if (this.currentTemplate === 'flowers') {
                        const petalMove = Math.sin(time * animData.speed + animData.phase * animData.petalCount) * 0.5;
                        x += petalMove * Math.cos(animData.angle);
                        y += petalMove * Math.sin(animData.angle);
                    }
                    else if (this.currentTemplate === 'saturn') {
                        const rotation = time * animData.speed * 0.5;
                        const newX = x * Math.cos(rotation) - z * Math.sin(rotation);
                        const newZ = x * Math.sin(rotation) + z * Math.cos(rotation);
                        x = newX;
                        z = newZ;
                    }
                    else if (this.currentTemplate === 'spiral') {
                        const spiralRotation = time * (0.05 + animData.speed * 0.1);
                        const newX = x * Math.cos(spiralRotation) - z * Math.sin(spiralRotation);
                        const newZ = x * Math.sin(spiralRotation) + z * Math.cos(spiralRotation);
                        x = newX;
                        z = newZ;
                        y += Math.sin(time * 0.5 + animData.phase) * 0.5;
                    }
                    else if (this.currentTemplate === 'swarm') {
                        const swarmMove = Math.sin(time * animData.speed + animData.phase) * animData.randomness;
                        x += swarmMove * Math.cos(animData.angle);
                        y += swarmMove * Math.sin(animData.angle);
                        z += swarmMove * Math.cos(animData.phase);
                    }
                    
                    // Hand gesture effects
                    if (this.isHandClosed) {
                        // Contract particles and change color
                        const contractFactor = 0.7;
                        x *= contractFactor;
                        y *= contractFactor;
                        z *= contractFactor;
                        
                        // Color shift
                        colors[i] = 0.8 + Math.sin(time + idx) * 0.2; // Red
                        colors[i + 1] = 0.2 + Math.cos(time + idx) * 0.2; // Green
                        colors[i + 2] = 0.5 + Math.sin(time * 0.5 + idx) * 0.3; // Blue
                    } 
                    else if (this.isPointing) {
                        // Move particles in pointing direction
                        x += handX * 0.1;
                        y += handY * 0.1;
                        z += handZ * 0.1;
                    } 
                    else {
                        // Open hand - expand particles and follow hand
                        const expandFactor = 1.3;
                        x *= expandFactor;
                        y *= expandFactor;
                        z *= expandFactor;
                        
                        // Move toward hand position
                        const attractStrength = 0.05;
                        x += (handX - x) * attractStrength;
                        y += (handY - y) * attractStrength;
                        z += (handZ - z) * attractStrength;
                    }
                    
                    // Apply color intensity
                    colors[i] *= this.colorIntensity;
                    colors[i + 1] *= this.colorIntensity;
                    colors[i + 2] *= this.colorIntensity;
                    
                    // Update positions
                    positions[i] = x;
                    positions[i + 1] = y;
                    positions[i + 2] = z;
                }
                
                // Mark attributes as needing update
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.geometry.attributes.color.needsUpdate = true;
                
                // Rotate camera slowly for better viewing
                this.camera.position.x = Math.sin(time * 0.1) * 30;
                this.camera.position.z = Math.cos(time * 0.1) * 30;
                this.camera.lookAt(0, 0, 0);
            }
            
            updateFPS() {
                this.frameCount++;
                const currentTime = performance.now() / 1000;
                
                if (currentTime - this.lastFpsUpdate >= 1) {
                    this.fpsCounter.textContent = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update particles
                this.updateParticles();
                
                // Update FPS counter
                this.updateFPS();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the application when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const particleSystem = new ParticleSystem();
        });
    </script>
</body>
    </html>
