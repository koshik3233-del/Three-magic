<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Particle Drawing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            padding: 15px 20px;
            background: rgba(10, 10, 26, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-right: 20px;
        }
        
        .container {
            display: flex;
            flex: 1;
            position: relative;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .sidebar {
            width: 280px;
            background: rgba(20, 20, 40, 0.85);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #4a9eff;
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
            padding-bottom: 5px;
        }
        
        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .shape-btn {
            padding: 10px;
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(100, 100, 200, 0.3);
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .shape-btn:hover {
            background: rgba(40, 40, 80, 0.9);
            color: #ddd;
        }
        
        .shape-btn.active {
            background: rgba(74, 158, 255, 0.3);
            border-color: #4a9eff;
            color: #fff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .slider-value {
            float: right;
            color: #4a9eff;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .gesture-info {
            background: rgba(30, 30, 60, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #ff00cc;
        }
        
        .gesture-info h3 {
            color: #ff00cc;
            margin-bottom: 10px;
        }
        
        .gesture-info p {
            color: #aaa;
            line-height: 1.5;
        }
        
        .status-bar {
            padding: 10px 20px;
            background: rgba(10, 10, 26, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid rgba(74, 158, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            z-index: 5;
            background: #000;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .gesture-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .gesture-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
            border-radius: 50%;
        }
        
        .gesture-drawing { background-color: #4CAF50; }
        .gesture-erasing { background-color: #FF5722; }
        .gesture-special { background-color: #2196F3; }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 26, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .spinner {
            border: 5px solid rgba(74, 158, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid #4a9eff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 300px;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .camera-feed {
                width: 150px;
                height: 113px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Hand Gesture Particle Drawing</h1>
        <div class="gesture-indicator">
            <span class="gesture-icon gesture-drawing" id="gesture-icon"></span>
            <span id="gesture-status">Loading hand tracking...</span>
        </div>
    </header>
    
    <div class="container">
        <div id="canvas-container">
            <canvas id="three-canvas"></canvas>
            
            <div class="camera-feed">
                <video id="video" autoplay muted></video>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="control-group">
                <h2>Drawing Shapes</h2>
                <div class="shape-buttons">
                    <button class="shape-btn active" data-shape="heart">‚ù§Ô∏è Heart</button>
                    <button class="shape-btn" data-shape="circle">‚≠ï Circle</button>
                    <button class="shape-btn" data-shape="star">‚≠ê Star</button>
                    <button class="shape-btn" data-shape="spiral">üåÄ Spiral</button>
                    <button class="shape-btn" data-shape="square">‚¨õ Square</button>
                    <button class="shape-btn" data-shape="flower">üåº Flower</button>
                    <button class="shape-btn" data-shape="triangle">‚ñ≤ Triangle</button>
                    <button class="shape-btn" data-shape="wave">üåä Wave</button>
                    <button class="shape-btn" data-shape="firework">üéÜ Firework</button>
                </div>
            </div>
            
            <div class="control-group">
                <h2>Drawing Controls</h2>
                <div class="slider-container">
                    <label>Particle Size <span class="slider-value" id="size-value">8</span></label>
                    <input type="range" id="size-slider" min="1" max="30" value="8" step="1">
                </div>
                
                <div class="slider-container">
                    <label>Drawing Speed <span class="slider-value" id="speed-value">50</span></label>
                    <input type="range" id="speed-slider" min="10" max="200" value="50" step="10">
                </div>
                
                <div class="slider-container">
                    <label>Trail Length <span class="slider-value" id="trail-value">20</span></label>
                    <input type="range" id="trail-slider" min="5" max="100" value="20" step="5">
                </div>
                
                <div class="slider-container">
                    <label>Color Intensity <span class="slider-value" id="color-value">1.0</span></label>
                    <input type="range" id="color-slider" min="0.1" max="2" value="1.0" step="0.1">
                </div>
                
                <div style="margin-top: 15px;">
                    <button id="clear-btn" style="width: 100%; padding: 12px; background: #ff4444; border: none; color: white; border-radius: 6px; cursor: pointer;">
                        Clear All Particles
                    </button>
                </div>
            </div>
            
            <div class="gesture-info">
                <h3>Hand Gesture Controls</h3>
                <p><strong>Open Hand (Palm facing camera):</strong> Draw selected shape at hand position</p>
                <p><strong>Closed Fist:</strong> Erase particles near hand</p>
                <p><strong>Peace Sign (‚úåÔ∏è):</strong> Create explosion effect</p>
                <p><strong>Thumbs Up (üëç):</strong> Rainbow color mode</p>
                <p><strong>Pointing (üëÜ):</strong> Draw line/trail from finger</p>
                <p>Move your hand in front of your camera to draw with particles.</p>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <div>Particles: <span id="particle-count">0</span> | FPS: <span id="fps-counter">0</span></div>
        <div>Drawing: <span id="shape-name">Heart</span> | Gesture: <span id="current-gesture">None</span></div>
    </div>
    
    <div class="loading" id="loading-screen">
        <div class="spinner"></div>
        <p>Initializing hand tracking and 3D particle system...</p>
        <p>Please allow camera access when prompted.</p>
    </div>

    <script>
        // Main Three.js application
        class HandDrawingSystem {
            constructor() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('three-canvas'),
                    antialias: true,
                    alpha: true 
                });
                
                // Particle systems
                this.particles = new THREE.Group();
                this.scene.add(this.particles);
                this.particleCount = 0;
                this.activeParticleSets = [];
                this.maxParticles = 20000;
                
                // Drawing properties
                this.particleSize = 8;
                this.drawingSpeed = 50; // Particles per second
                this.trailLength = 20;
                this.colorIntensity = 1.0;
                this.currentShape = 'heart';
                this.shapes = {
                    'heart': this.createHeartShape,
                    'circle': this.createCircleShape,
                    'star': this.createStarShape,
                    'spiral': this.createSpiralShape,
                    'square': this.createSquareShape,
                    'flower': this.createFlowerShape,
                    'triangle': this.createTriangleShape,
                    'wave': this.createWaveShape,
                    'firework': this.createFireworkShape
                };
                
                // Hand tracking
                this.hands = null;
                this.videoElement = document.getElementById('video');
                this.gestureStatus = document.getElementById('gesture-status');
                this.gestureIcon = document.getElementById('gesture-icon');
                this.lastGesture = 'none';
                
                // Hand state
                this.handDetected = false;
                this.handPosition = { x: 0, y: 0, z: -20 };
                this.handRotation = { x: 0, y: 0, z: 0 };
                this.lastHandPositions = [];
                this.gestureState = {
                    isDrawing: false,
                    isErasing: false,
                    isSpecial: false,
                    isRainbow: false,
                    isPointing: false
                };
                
                // Drawing state
                this.lastDrawTime = 0;
                this.drawInterval = 1000 / this.drawingSpeed;
                this.trailPoints = [];
                
                // Animation
                this.clock = new THREE.Clock();
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                // UI elements
                this.sizeSlider = document.getElementById('size-slider');
                this.speedSlider = document.getElementById('speed-slider');
                this.trailSlider = document.getElementById('trail-slider');
                this.colorSlider = document.getElementById('color-slider');
                this.sizeValue = document.getElementById('size-value');
                this.speedValue = document.getElementById('speed-value');
                this.trailValue = document.getElementById('trail-value');
                this.colorValue = document.getElementById('color-value');
                this.particleCountDisplay = document.getElementById('particle-count');
                this.fpsCounter = document.getElementById('fps-counter');
                this.shapeName = document.getElementById('shape-name');
                this.currentGestureDisplay = document.getElementById('current-gesture');
                this.shapeButtons = document.querySelectorAll('.shape-btn');
                this.clearButton = document.getElementById('clear-btn');
                this.loadingScreen = document.getElementById('loading-screen');
                
                this.init();
            }
            
            init() {
                // Setup Three.js
                this.setupScene();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Setup hand tracking
                this.setupHandTracking();
                
                // Create background
                this.createBackground();
                
                // Start animation loop
                this.animate();
                
                // Hide loading screen after a delay
                setTimeout(() => {
                    this.loadingScreen.style.display = 'none';
                }, 2000);
            }
            
            setupScene() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x0a0a1a, 1);
                
                // Setup camera
                this.camera.position.set(0, 0, 50);
                this.camera.lookAt(0, 0, 0);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 10);
                this.scene.add(directionalLight);
                
                // Add subtle fog for depth
                this.scene.fog = new THREE.Fog(0x0a0a1a, 50, 150);
            }
            
            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Slider controls
                this.sizeSlider.addEventListener('input', (e) => {
                    this.particleSize = parseInt(e.target.value);
                    this.sizeValue.textContent = this.particleSize;
                });
                
                this.speedSlider.addEventListener('input', (e) => {
                    this.drawingSpeed = parseInt(e.target.value);
                    this.speedValue.textContent = this.drawingSpeed;
                    this.drawInterval = 1000 / this.drawingSpeed;
                });
                
                this.trailSlider.addEventListener('input', (e) => {
                    this.trailLength = parseInt(e.target.value);
                    this.trailValue.textContent = this.trailLength;
                });
                
                this.colorSlider.addEventListener('input', (e) => {
                    this.colorIntensity = parseFloat(e.target.value);
                    this.colorValue.textContent = this.colorIntensity;
                });
                
                // Shape buttons
                this.shapeButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        const shape = e.target.dataset.shape;
                        this.setShape(shape);
                        
                        // Update active button
                        this.shapeButtons.forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });
                
                // Clear button
                this.clearButton.addEventListener('click', () => {
                    this.clearAllParticles();
                });
            }
            
            setupHandTracking() {
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                this.hands.onResults(this.onHandResults.bind(this));
                
                // Start camera
                const camera = new Camera(this.videoElement, {
                    onFrame: async () => {
                        await this.hands.send({ image: this.videoElement });
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
            }
            
            onHandResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const handedness = results.multiHandedness[0].label;
                    
                    this.handDetected = true;
                    
                    // Calculate hand center position (using palm base landmarks)
                    const wrist = landmarks[0];
                    const indexMCP = landmarks[5];
                    const pinkyMCP = landmarks[17];
                    
                    // Convert to 3D space
                    const screenX = (wrist.x + indexMCP.x + pinkyMCP.x) / 3;
                    const screenY = (wrist.y + indexMCP.y + pinkyMCP.y) / 3;
                    const depth = wrist.z;
                    
                    // Map to 3D world coordinates
                    this.handPosition.x = (screenX - 0.5) * 40;
                    this.handPosition.y = -(screenY - 0.5) * 30;
                    this.handPosition.z = depth * 50 - 30;
                    
                    // Store hand position for trail
                    this.lastHandPositions.unshift({
                        x: this.handPosition.x,
                        y: this.handPosition.y,
                        z: this.handPosition.z,
                        time: Date.now()
                    });
                    
                    // Keep only recent positions
                    if (this.lastHandPositions.length > 10) {
                        this.lastHandPositions.pop();
                    }
                    
                    // Detect gestures
                    this.detectGestures(landmarks, handedness);
                } else {
                    this.handDetected = false;
                    this.gestureStatus.textContent = "No hand detected";
                    this.gestureIcon.className = "gesture-icon";
                    this.currentGestureDisplay.textContent = "None";
                    this.lastGesture = 'none';
                }
            }
            
            detectGestures(landmarks, handedness) {
                // Get key landmarks
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const wrist = landmarks[0];
                
                // Calculate distances from wrist
                const distances = {
                    thumb: this.distance(thumbTip, wrist),
                    index: this.distance(indexTip, wrist),
                    middle: this.distance(middleTip, wrist),
                    ring: this.distance(ringTip, wrist),
                    pinky: this.distance(pinkyTip, wrist)
                };
                
                const avgDistance = (distances.thumb + distances.index + distances.middle + distances.ring + distances.pinky) / 5;
                
                // Reset gesture states
                this.gestureState.isDrawing = false;
                this.gestureState.isErasing = false;
                this.gestureState.isSpecial = false;
                this.gestureState.isRainbow = false;
                this.gestureState.isPointing = false;
                
                let gestureName = "Open Hand";
                let gestureType = "drawing";
                
                // Detect closed fist (all fingers close to wrist)
                if (distances.index < avgDistance * 0.6 && 
                    distances.middle < avgDistance * 0.6 &&
                    distances.ring < avgDistance * 0.6) {
                    this.gestureState.isErasing = true;
                    gestureName = "Closed Fist (Erasing)";
                    gestureType = "erasing";
                }
                // Detect peace sign (index and middle extended)
                else if (distances.index > avgDistance * 1.4 && 
                         distances.middle > avgDistance * 1.4 &&
                         distances.ring < avgDistance * 0.8 &&
                         distances.pinky < avgDistance * 0.8) {
                    this.gestureState.isSpecial = true;
                    gestureName = "Peace Sign ‚úåÔ∏è";
                    gestureType = "special";
                }
                // Detect thumbs up (thumb extended, others closed)
                else if (distances.thumb > avgDistance * 1.5 &&
                         distances.index < avgDistance * 0.7 &&
                         distances.middle < avgDistance * 0.7) {
                    this.gestureState.isRainbow = true;
                    gestureName = "Thumbs Up üëç";
                    gestureType = "special";
                }
                // Detect pointing (only index extended)
                else if (distances.index > avgDistance * 1.4 &&
                         distances.middle < avgDistance * 0.8 &&
                         distances.thumb < avgDistance * 1.0) {
                    this.gestureState.isPointing = true;
                    gestureName = "Pointing üëÜ";
                    gestureType = "special";
                }
                // Default open hand
                else {
                    this.gestureState.isDrawing = true;
                    gestureName = "Open Hand (Drawing)";
                    gestureType = "drawing";
                }
                
                // Update UI
                this.updateGestureUI(gestureType, gestureName);
                this.currentGestureDisplay.textContent = gestureName;
            }
            
            distance(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const dz = point1.z - point2.z;
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            }
            
            updateGestureUI(gestureType, gestureText) {
                if (this.lastGesture !== gestureType) {
                    this.gestureStatus.textContent = gestureText;
                    this.gestureIcon.className = "gesture-icon";
                    
                    if (gestureType === 'drawing') {
                        this.gestureIcon.classList.add('gesture-drawing');
                    } else if (gestureType === 'erasing') {
                        this.gestureIcon.classList.add('gesture-erasing');
                    } else if (gestureType === 'special') {
                        this.gestureIcon.classList.add('gesture-special');
                    }
                    
                    this.lastGesture = gestureType;
                }
            }
            
            setShape(shapeName) {
                this.currentShape = shapeName;
                this.shapeName.textContent = shapeName.charAt(0).toUpperCase() + shapeName.slice(1);
            }
            
            createHeartShape(count = 100, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * Math.PI * 2;
                    const scale = size * (0.8 + Math.random() * 0.4);
                    
                    // Heart parametric equations
                    const x = scale * 16 * Math.pow(Math.sin(t), 3);
                    const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    
                    particles.push({
                        x: position.x + x * 0.03,
                        y: position.y - y * 0.03,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                }
                return particles;
            }
            
            createCircleShape(count = 100, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = size * (0.9 + Math.random() * 0.2);
                    
                    particles.push({
                        x: position.x + Math.cos(angle) * radius,
                        y: position.y + Math.sin(angle) * radius,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                }
                return particles;
            }
            
            createStarShape(count = 100, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                const points = 5;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = size * (0.5 + 0.5 * Math.abs(Math.sin(angle * points / 2)));
                    
                    particles.push({
                        x: position.x + Math.cos(angle) * radius,
                        y: position.y + Math.sin(angle) * radius,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                }
                return particles;
            }
            
            createSpiralShape(count = 200, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * Math.PI * 8;
                    const radius = (i / count) * size * 2;
                    
                    particles.push({
                        x: position.x + Math.cos(t) * radius,
                        y: position.y + Math.sin(t) * radius,
                        z: position.z + (i / count - 0.5) * 10
                    });
                }
                return particles;
            }
            
            createSquareShape(count = 100, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                const sideLength = size * 2;
                const particlesPerSide = Math.floor(count / 4);
                
                // Create square edges
                for (let i = 0; i < particlesPerSide; i++) {
                    // Top
                    particles.push({
                        x: position.x + (i / particlesPerSide - 0.5) * sideLength,
                        y: position.y + size,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                    // Bottom
                    particles.push({
                        x: position.x + (i / particlesPerSide - 0.5) * sideLength,
                        y: position.y - size,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                    // Left
                    particles.push({
                        x: position.x - size,
                        y: position.y + (i / particlesPerSide - 0.5) * sideLength,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                    // Right
                    particles.push({
                        x: position.x + size,
                        y: position.y + (i / particlesPerSide - 0.5) * sideLength,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                }
                
                return particles.slice(0, count);
            }
            
            createFlowerShape(count = 150, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                const petals = 6;
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * Math.PI * 2;
                    const radius = size * (1 + 0.3 * Math.sin(t * petals));
                    
                    particles.push({
                        x: position.x + Math.cos(t) * radius,
                        y: position.y + Math.sin(t) * radius,
                        z: position.z + (Math.random() - 0.5) * 3
                    });
                }
                return particles;
            }
            
            createTriangleShape(count = 100, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    const t = (i / count) * 3;
                    const side = Math.floor(t);
                    const pos = t - side;
                    
                    let x, y;
                    if (side === 0) { // Left side
                        x = -size + pos * size;
                        y = size - pos * 2 * size;
                    } else if (side === 1) { // Right side
                        x = size - pos * size;
                        y = -size + pos * 2 * size;
                    } else { // Bottom side
                        x = size - pos * 2 * size;
                        y = -size;
                    }
                    
                    particles.push({
                        x: position.x + x,
                        y: position.y + y,
                        z: position.z + (Math.random() - 0.5) * 2
                    });
                }
                return particles;
            }
            
            createWaveShape(count = 200, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    const x = (i / count - 0.5) * size * 4;
                    const y = Math.sin(x * 0.5) * size;
                    
                    particles.push({
                        x: position.x + x,
                        y: position.y + y,
                        z: position.z + (Math.random() - 0.5) * 3
                    });
                }
                return particles;
            }
            
            createFireworkShape(count = 300, position = {x: 0, y: 0, z: 0}, size = 5) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    // Random spherical explosion
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const radius = size * (0.5 + Math.random() * 1.5);
                    
                    particles.push({
                        x: position.x + radius * Math.sin(phi) * Math.cos(theta),
                        y: position.y + radius * Math.sin(phi) * Math.sin(theta),
                        z: position.z + radius * Math.cos(phi)
                    });
                }
                return particles;
            }
            
            createBackground() {
                // Add subtle grid for reference
                const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
                gridHelper.position.y = -15;
                this.scene.add(gridHelper);
                
                // Add distant stars
                const starCount = 300;
                const starGeometry = new THREE.BufferGeometry();
                const starPositions = [];
                const starColors = [];
                
                for (let i = 0; i < starCount; i++) {
                    const radius = 80 + Math.random() * 100;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    starPositions.push(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                    
                    const brightness = 0.1 + Math.random() * 0.2;
                    starColors.push(brightness, brightness, brightness);
                }
                
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(stars);
            }
            
            createParticle(x, y, z, color = null) {
                if (this.particleCount >= this.maxParticles) {
                    // Remove oldest particle set if we're at capacity
                    if (this.activeParticleSets.length > 0) {
                        const oldestSet = this.activeParticleSets.shift();
                        this.particles.remove(oldestSet);
                        oldestSet.geometry.dispose();
                        oldestSet.material.dispose();
                        this.particleCount -= oldestSet.geometry.attributes.position.count / 3;
                    }
                }
                
                // Create color
                let particleColor;
                if (this.gestureState.isRainbow) {
                    // Rainbow colors based on position and time
                    const time = this.clock.getElapsedTime();
                    const hue = ((Math.sin(x * 0.1 + y * 0.05 + time) * 0.5 + 0.5) * 360) % 360;
                    particleColor = this.hslToRgb(hue / 360, 0.8, 0.6);
                } else if (color) {
                    particleColor = color;
                } else {
                    // Default color based on position
                    const r = 0.5 + 0.5 * Math.sin(x * 0.2);
                    const g = 0.5 + 0.5 * Math.cos(y * 0.2);
                    const b = 0.5 + 0.5 * Math.sin((x + y) * 0.1);
                    particleColor = { r, g, b };
                }
                
                // Create geometry for single particle
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([x, y, z]);
                const colors = new Float32Array([
                    particleColor.r * this.colorIntensity,
                    particleColor.g * this.colorIntensity,
                    particleColor.b * this.colorIntensity
                ]);
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Create material
                const material = new THREE.PointsMaterial({
                    size: this.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                
                // Create points object
                const points = new THREE.Points(geometry, material);
                this.particles.add(points);
                
                // Store for cleanup
                this.activeParticleSets.push(points);
                this.particleCount++;
                this.particleCountDisplay.textContent = this.particleCount;
                
                return points;
            }
            
            createParticleGroup(positions, colors = null) {
                if (positions.length === 0) return null;
                
                const geometry = new THREE.BufferGeometry();
                const positionArray = new Float32Array(positions.length * 3);
                const colorArray = new Float32Array(positions.length * 3);
                
                for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    positionArray[i * 3] = pos.x;
                    positionArray[i * 3 + 1] = pos.y;
                    positionArray[i * 3 + 2] = pos.z;
                    
                    // Assign colors
                    if (colors && colors[i]) {
                        colorArray[i * 3] = colors[i].r * this.colorIntensity;
                        colorArray[i * 3 + 1] = colors[i].g * this.colorIntensity;
                        colorArray[i * 3 + 2] = colors[i].b * this.colorIntensity;
                    } else {
                        // Default color gradient
                        const hue = (i / positions.length) * 360;
                        const rgb = this.hslToRgb(hue / 360, 0.8, 0.6);
                        colorArray[i * 3] = rgb.r * this.colorIntensity;
                        colorArray[i * 3 + 1] = rgb.g * this.colorIntensity;
                        colorArray[i * 3 + 2] = rgb.b * this.colorIntensity;
                    }
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
                
                const material = new THREE.PointsMaterial({
                    size: this.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const points = new THREE.Points(geometry, material);
                this.particles.add(points);
                this.activeParticleSets.push(points);
                this.particleCount += positions.length;
                this.particleCountDisplay.textContent = this.particleCount;
                
                return points;
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return { r, g, b };
            }
            
            drawShape() {
                if (!this.handDetected) return;
                
                const currentTime = Date.now();
                if (currentTime - this.lastDrawTime < this.drawInterval) return;
                
                this.lastDrawTime = currentTime;
                
                if (this.gestureState.isDrawing) {
                    // Draw the selected shape
                    const shapeFunction = this.shapes[this.currentShape];
                    const particleCount = Math.floor(this.drawingSpeed / 10);
                    const shapeParticles = shapeFunction.call(this, particleCount, this.handPosition, 3 + Math.random() * 2);
                    
                    this.createParticleGroup(shapeParticles);
                }
                else if (this.gestureState.isPointing) {
                    // Draw trail from finger
                    if (this.lastHandPositions.length >= 2) {
                        const from = this.lastHandPositions[1];
                        const to = this.lastHandPositions[0];
                        
                        // Create trail particles
                        const trailPoints = [];
                        const steps = 5;
                        for (let i = 0; i < steps; i++) {
                            const t = i / steps;
                            trailPoints.push({
                                x: from.x + (to.x - from.x) * t,
                                y: from.y + (to.y - from.y) * t,
                                z: from.z + (to.z - from.z) * t
                            });
                        }
                        
                        this.createParticleGroup(trailPoints);
                    }
                }
                else if (this.gestureState.isSpecial) {
                    // Special effects (peace sign)
                    const explosionParticles = this.createFireworkShape(50, this.handPosition, 2);
                    this.createParticleGroup(explosionParticles);
                }
            }
            
            eraseParticles() {
                if (!this.handDetected || !this.gestureState.isErasing) return;
                
                const eraseRadius = 8;
                const particlesToRemove = [];
                
                // Find particles near hand to erase
                for (let i = this.activeParticleSets.length - 1; i >= 0; i--) {
                    const particleSet = this.activeParticleSets[i];
                    const positions = particleSet.geometry.attributes.position.array;
                    
                    for (let j = 0; j < positions.length; j += 3) {
                        const dx = positions[j] - this.handPosition.x;
                        const dy = positions[j + 1] - this.handPosition.y;
                        const dz = positions[j + 2] - this.handPosition.z;
                        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (distance < eraseRadius) {
                            // Mark for removal
                            particlesToRemove.push({ setIndex: i, particleIndex: j });
                            break; // Remove entire set if any particle is close
                        }
                    }
                }
                
                // Remove marked particle sets
                particlesToRemove.forEach(({ setIndex }) => {
                    const removedSet = this.activeParticleSets.splice(setIndex, 1)[0];
                    this.particles.remove(removedSet);
                    this.particleCount -= removedSet.geometry.attributes.position.count / 3;
                    removedSet.geometry.dispose();
                    removedSet.material.dispose();
                });
                
                this.particleCountDisplay.textContent = this.particleCount;
            }
            
            clearAllParticles() {
                // Remove all particle sets
                while (this.activeParticleSets.length > 0) {
                    const particleSet = this.activeParticleSets.pop();
                    this.particles.remove(particleSet);
                    particleSet.geometry.dispose();
                    particleSet.material.dispose();
                }
                
                this.particleCount = 0;
                this.particleCountDisplay.textContent = "0";
            }
            
            updateFPS() {
                this.frameCount++;
                const currentTime = performance.now() / 1000;
                
                if (currentTime - this.lastFpsUpdate >= 1) {
                    this.fpsCounter.textContent = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update based on hand gestures
                if (this.handDetected) {
                    this.drawShape();
                    this.eraseParticles();
                }
                
                // Animate particles (floating motion)
                const time = this.clock.getElapsedTime();
                this.particles.children.forEach((particleSet, index) => {
                    const positions = particleSet.geometry.attributes.position.array;
                    const age = time - (index / this.activeParticleSets.length) * 10;
                    
                    // Gentle floating animation
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += Math.sin(age + i * 0.01) * 0.01;
                        positions[i + 1] += Math.cos(age + i * 0.01) * 0.01;
                        positions[i + 2] += Math.sin(age * 0.5 + i * 0.02) * 0.005;
                    }
                    
                    particleSet.geometry.attributes.position.needsUpdate = true;
                });
                
                // Slowly rotate camera for better view
                this.camera.position.x = Math.sin(time * 0.1) * 40;
                this.camera.position.y = Math.sin(time * 0.05) * 10;
                this.camera.lookAt(0, 0, 0);
                
                // Update FPS counter
                this.updateFPS();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the application when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const drawingSystem = new HandDrawingSystem();
        });
    </script>
</body>
    </html>
