<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Controlled Particles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video */
            display: none;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #outputCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #00ff88;
        }
        
        .status {
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        
        .gesture-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            border-left: 3px solid #00ff88;
        }
        
        .gesture-list {
            margin-top: 10px;
            font-size: 0.85rem;
        }
        
        .gesture-list li {
            margin-bottom: 5px;
            padding-left: 10px;
        }
        
        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }
        
        .particle-count {
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            text-align: center;
            font-size: 1.2rem;
            color: #00ff88;
        }
        
        .debug {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            max-width: 200px;
            backdrop-filter: blur(5px);
        }
    </style>
    <!-- Import TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <!-- Import handpose model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
</head>
<body>
    <div class="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="outputCanvas"></canvas>
        
        <div class="controls">
            <h1>ðŸ‘‹ Hand Gesture Particles</h1>
            <div class="status" id="status">Initializing camera...</div>
            <div class="gesture-info">
                <strong>Current Gesture: </strong><span id="gestureText">None detected</span>
            </div>
            <div class="gesture-list">
                <strong>Gesture Commands:</strong>
                <ul>
                    <li>ðŸ‘† Single finger - Move particles</li>
                    <li>ðŸ”„ Rotate hand front to back - Create Circle</li>
                    <li>ðŸ’– Rotate hand twice - Create Heart</li>
                    <li>âœŠ Make fist - Clear shapes</li>
                </ul>
            </div>
            <button id="startButton">Start Camera</button>
            <div class="particle-count">
                <label for="particleSlider">Particle Count: <span id="particleCount">200</span></label>
                <input type="range" id="particleSlider" min="50" max="500" value="200" step="10">
            </div>
        </div>
        
        <div class="debug" id="debugInfo">
            <div>Landmarks: <span id="landmarkCount">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
        
        <div id="loading">
            Loading hand detection model...
        </div>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const gestureText = document.getElementById('gestureText');
        const startButton = document.getElementById('startButton');
        const loadingDiv = document.getElementById('loading');
        const particleSlider = document.getElementById('particleSlider');
        const particleCount = document.getElementById('particleCount');
        const debugInfo = document.getElementById('debugInfo');
        const landmarkCount = document.getElementById('landmarkCount');
        const fpsDisplay = document.getElementById('fps');
        
        // Variables
        let model = null;
        let particles = [];
        let isDetecting = false;
        let lastGesture = 'none';
        let gestureStartTime = 0;
        let rotationCount = 0;
        let lastRotationTime = 0;
        let rotationDirection = 0; // -1 for clockwise, 1 for counterclockwise
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        
        // Particle system configuration
        const particleConfig = {
            count: 200,
            colors: ['#ff0080', '#00ff88', '#0080ff', '#ff8000'],
            maxSpeed: 3,
            size: 3
        };
        
        // Initialize particles
        function initParticles(count) {
            particles = [];
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: particleConfig.colors[Math.floor(Math.random() * particleConfig.colors.length)],
                    size: Math.random() * particleConfig.size + 1,
                    targetX: null,
                    targetY: null,
                    shape: 'free', // 'free', 'circle', 'heart'
                    shapeProgress: 0
                });
            }
        }
        
        // Update particles
        function updateParticles(handData) {
            if (!handData) {
                // No hand detected - random movement
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Bounce off walls
                    if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
                    if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
                    
                    // Add some randomness
                    p.vx += (Math.random() - 0.5) * 0.1;
                    p.vy += (Math.random() - 0.5) * 0.1;
                    
                    // Limit speed
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    if (speed > particleConfig.maxSpeed) {
                        p.vx = (p.vx / speed) * particleConfig.maxSpeed;
                        p.vy = (p.vy / speed) * particleConfig.maxSpeed;
                    }
                });
                return;
            }
            
            const landmarks = handData.landmarks;
            const indexFingerTip = landmarks[8]; // Index finger tip
            const middleFingerTip = landmarks[12]; // Middle finger tip
            const ringFingerTip = landmarks[16]; // Ring finger tip
            const pinkyTip = landmarks[20]; // Pinky tip
            const wrist = landmarks[0]; // Wrist
            
            // Calculate hand center and orientation
            const handCenter = {
                x: landmarks.reduce((sum, lm) => sum + lm[0], 0) / landmarks.length,
                y: landmarks.reduce((sum, lm) => sum + lm[1], 0) / landmarks.length
            };
            
            // Map coordinates from video to screen
            const screenX = (handCenter[0] / video.videoWidth) * window.innerWidth;
            const screenY = (handCenter[1] / video.videoHeight) * window.innerHeight;
            
            // Detect gesture based on finger positions
            const gesture = detectGesture(landmarks);
            updateGestureDisplay(gesture);
            
            // Apply gesture effects
            switch(gesture) {
                case 'point':
                    // Pointing - attract particles to finger
                    particles.forEach(p => {
                        const dx = screenX - p.x;
                        const dy = screenY - p.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 300) {
                            const force = 0.1;
                            p.vx += (dx / distance) * force;
                            p.vy += (dy / distance) * force;
                        }
                    });
                    break;
                    
                case 'circle':
                    // Form a circle around hand
                    createShape('circle', screenX, screenY, 150);
                    break;
                    
                case 'heart':
                    // Form a heart shape
                    createShape('heart', screenX, screenY, 200);
                    break;
                    
                case 'fist':
                    // Clear shapes and scatter particles
                    particles.forEach(p => {
                        p.shape = 'free';
                        p.shapeProgress = 0;
                        // Add explosion effect
                        p.vx += (Math.random() - 0.5) * 10;
                        p.vy += (Math.random() - 0.5) * 10;
                    });
                    break;
            }
            
            // Update particle positions
            particles.forEach(p => {
                if (p.shape === 'free') {
                    p.x += p.vx;
                    p.y += p.vy;
                } else {
                    // Move towards shape
                    p.shapeProgress += 0.02;
                    if (p.shapeProgress > 1) p.shapeProgress = 1;
                    
                    const ease = p.shapeProgress < 0.5 ? 
                        2 * p.shapeProgress * p.shapeProgress : 
                        1 - Math.pow(-2 * p.shapeProgress + 2, 2) / 2;
                    
                    if (p.targetX !== null && p.targetY !== null) {
                        p.x += (p.targetX - p.x) * 0.1 * ease;
                        p.y += (p.targetY - p.y) * 0.1 * ease;
                    }
                }
                
                // Apply friction
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                // Keep particles on screen
                if (p.x < 0) { p.x = 0; p.vx *= -1; }
                if (p.x > window.innerWidth) { p.x = window.innerWidth; p.vx *= -1; }
                if (p.y < 0) { p.y = 0; p.vy *= -1; }
                if (p.y > window.innerHeight) { p.y = window.innerHeight; p.vy *= -1; }
            });
        }
        
        // Create shape with particles
        function createShape(shape, centerX, centerY, radius) {
            const angleStep = (2 * Math.PI) / particles.length;
            
            particles.forEach((p, i) => {
                p.shape = shape;
                p.shapeProgress = 0;
                
                let targetX, targetY;
                const angle = angleStep * i;
                
                if (shape === 'circle') {
                    targetX = centerX + Math.cos(angle) * radius;
                    targetY = centerY + Math.sin(angle) * radius;
                } else if (shape === 'heart') {
                    // Heart shape parametric equation
                    const t = angle;
                    targetX = centerX + 16 * Math.pow(Math.sin(t), 3) * (radius / 20);
                    targetY = centerY - (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * (radius / 20);
                }
                
                p.targetX = targetX;
                p.targetY = targetY;
            });
        }
        
        // Detect hand gesture
        function detectGesture(landmarks) {
            // Get key points
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // Calculate distances
            const indexToWrist = distance3D(indexTip, wrist);
            const middleToWrist = distance3D(middleTip, wrist);
            const ringToWrist = distance3D(ringTip, wrist);
            const pinkyToWrist = distance3D(pinkyTip, wrist);
            const thumbToWrist = distance3D(thumbTip, wrist);
            
            // Gesture detection logic
            
            // Fist detection - all fingers close to wrist
            if (indexToWrist < 0.2 && middleToWrist < 0.2 && 
                ringToWrist < 0.2 && pinkyToWrist < 0.2) {
                return 'fist';
            }
            
            // Pointing gesture - only index finger extended
            if (indexToWrist > 0.3 && middleToWrist < 0.2 && 
                ringToWrist < 0.2 && pinkyToWrist < 0.2) {
                return 'point';
            }
            
            // Calculate hand rotation based on wrist and middle finger
            const middleBase = landmarks[9];
            const wristToMiddle = {
                x: middleBase[0] - wrist[0],
                y: middleBase[1] - wrist[1],
                z: middleBase[2] - wrist[2]
            };
            
            // Detect rotation front to back (z-axis movement)
            const currentTime = Date.now();
            if (wristToMiddle.z > 0.1) {
                // Hand is facing forward
                if (rotationDirection === -1 && currentTime - lastRotationTime < 1000) {
                    rotationCount++;
                    lastRotationTime = currentTime;
                    
                    if (rotationCount === 1) {
                        // Single rotation - circle
                        return 'circle';
                    } else if (rotationCount >= 2) {
                        // Double rotation - heart
                        rotationCount = 0;
                        return 'heart';
                    }
                }
                rotationDirection = 1;
            } else if (wristToMiddle.z < -0.1) {
                // Hand is facing backward
                if (rotationDirection === 1 && currentTime - lastRotationTime < 1000) {
                    rotationDirection = -1;
                    lastRotationTime = currentTime;
                }
            }
            
            // Reset rotation count if too much time has passed
            if (currentTime - lastRotationTime > 1500) {
                rotationCount = 0;
            }
            
            return 'none';
        }
        
        // Update gesture display
        function updateGestureDisplay(gesture) {
            if (gesture !== lastGesture) {
                lastGesture = gesture;
                gestureText.textContent = gesture;
                
                if (gesture === 'circle') {
                    gestureText.innerHTML = 'ðŸ”„ Circle';
                } else if (gesture === 'heart') {
                    gestureText.innerHTML = 'ðŸ’– Heart';
                } else if (gesture === 'point') {
                    gestureText.innerHTML = 'ðŸ‘† Pointing';
                } else if (gesture === 'fist') {
                    gestureText.innerHTML = 'âœŠ Fist';
                } else {
                    gestureText.innerHTML = 'None';
                }
            }
        }
        
        // Draw particles
        function drawParticles() {
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // Draw connections between nearby particles
            outputCtx.strokeStyle = 'rgba(0, 255, 136, 0.2)';
            outputCtx.lineWidth = 1;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 80) {
                        outputCtx.beginPath();
                        outputCtx.moveTo(particles[i].x, particles[i].y);
                        outputCtx.lineTo(particles[j].x, particles[j].y);
                        outputCtx.stroke();
                    }
                }
            }
            
            // Draw particles
            particles.forEach(p => {
                outputCtx.beginPath();
                outputCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                outputCtx.fillStyle = p.color;
                outputCtx.fill();
                
                // Add glow effect
                outputCtx.beginPath();
                outputCtx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
                const gradient = outputCtx.createRadialGradient(
                    p.x, p.y, p.size,
                    p.x, p.y, p.size * 2
                );
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                outputCtx.fillStyle = gradient;
                outputCtx.fill();
            });
        }
        
        // Draw hand landmarks
        function drawHand(landmarks) {
            if (!landmarks) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#00ff88';
            ctx.fillStyle = '#00ff88';
            ctx.lineWidth = 2;
            
            // Draw connections
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8], // Index
                [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                [0, 17], [17, 18], [18, 19], [19, 20] // Pinky
            ];
            
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(
                    (startPoint[0] / video.videoWidth) * canvas.width,
                    (startPoint[1] / video.videoHeight) * canvas.height
                );
                ctx.lineTo(
                    (endPoint[0] / video.videoWidth) * canvas.width,
                    (endPoint[1] / video.videoHeight) * canvas.height
                );
                ctx.stroke();
            });
            
            // Draw landmarks
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(
                    (landmark[0] / video.videoWidth) * canvas.width,
                    (landmark[1] / video.videoHeight) * canvas.height,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            });
        }
        
        // Calculate 3D distance
        function distance3D(point1, point2) {
            const dx = point1[0] - point2[0];
            const dy = point1[1] - point2[1];
            const dz = point1[2] - point2[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        
        // Update FPS counter
        function updateFPS(currentTime) {
            frameCount++;
            if (currentTime - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
                fpsDisplay.textContent = fps;
            }
        }
        
        // Main detection loop
        async function detectHand() {
            if (!isDetecting || !model) return;
            
            const currentTime = performance.now();
            updateFPS(currentTime);
            
            // Get predictions
            const predictions = await model.estimateHands(video);
            
            if (predictions.length > 0) {
                const hand = predictions[0];
                landmarkCount.textContent = hand.landmarks.length;
                
                // Draw hand landmarks
                drawHand(hand.landmarks);
                
                // Update particles based on hand
                updateParticles(hand);
            } else {
                // No hand detected
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                landmarkCount.textContent = '0';
                updateParticles(null);
            }
            
            // Draw particles
            drawParticles();
            
            // Continue loop
            requestAnimationFrame(detectHand);
        }
        
        // Start camera
        async function startCamera() {
            try {
                loadingDiv.style.display = 'block';
                statusDiv.textContent = 'Starting camera...';
                
                // Get camera stream
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                
                video.srcObject = stream;
                
                // Wait for video to load
                await new Promise(resolve => {
                    video.onloadedmetadata = resolve;
                });
                
                video.play();
                
                // Set canvas dimensions
                canvas.width = outputCanvas.width = window.innerWidth;
                canvas.height = outputCanvas.height = window.innerHeight;
                
                // Load handpose model
                statusDiv.textContent = 'Loading hand detection model...';
                model = await handpose.load();
                
                // Initialize particles
                initParticles(particleConfig.count);
                
                // Start detection
                isDetecting = true;
                detectHand();
                
                // Update UI
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'Camera active - Show your hand!';
                startButton.style.display = 'none';
                
            } catch (error) {
                console.error('Error starting camera:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                loadingDiv.style.display = 'none';
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = outputCanvas.width = window.innerWidth;
            canvas.height = outputCanvas.height = window.innerHeight;
        });
        
        // Particle count slider
        particleSlider.addEventListener('input', () => {
            const count = parseInt(particleSlider.value);
            particleCount.textContent = count;
            particleConfig.count = count;
            initParticles(count);
        });
        
        // Start button
        startButton.addEventListener('click', startCamera);
        
        // Initial setup
        initParticles(particleConfig.count);
        loadingDiv.style.display = 'block';
        
        // Try to auto-start on page load
        setTimeout(() => {
            if (!model) {
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'Click "Start Camera" to begin';
            }
        }, 3000);
    </script>
</body>
</html>
